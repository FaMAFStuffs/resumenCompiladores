\documentclass[handout]{beamer}
\mode<presentation>{
  \usetheme[shadow=false]{Boadilla}
  \usefonttheme{professionalfonts}
  \usefonttheme[onlymath]{serif}
  \usecolortheme{dolphin}
  \useinnertheme{circles}
}

\usepackage[spanish]{babel}
\usepackage{amssymb} 
\usepackage{amsthm} 
\usepackage{tikz}
\usepackage{bussproofs}
\usepackage{stmaryrd}

%% FONTS
\usepackage[utf8]{inputenx}
\usepackage{fontenc}

\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{footline}{ 
  \hbox{%
  \begin{beamercolorbox}[wd=.50\paperwidth,ht=2.25ex,dp=1ex,center]{white}%
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.20\paperwidth,ht=2.25ex,dp=1ex,center]{white}%
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.30\paperwidth,ht=2.25ex,dp=1ex,left]{foot}%
    \textbf{\insertsection}
  \end{beamercolorbox}
  }%
  \vskip0pt%
}
\setbeamertemplate{footline}{}
\setbeamertemplate{headline}{
\hbox{
  \begin{beamercolorbox}[wd=\paperwidth,ht=2.25ex,dp=1ex,right]{white}%
    \color{black}\textbf{\insertframenumber{} }\hspace*{2em}
  \end{beamercolorbox}}
  \vspace{-.4cm}
}

\setbeamertemplate{section in toc}{\leftskip=2ex%
    \usebeamerfont*{section number projected}%
    \usebeamercolor{section number projected}%
    \begin{pgfpicture}{-1ex}{2pt}{1ex}{2.2ex}
      \color{bg}
      \pgfpathcircle{\pgfpoint{0pt}{1.5ex}}{1.8ex}
      \pgfusepath{fill}
      \pgftext[bottom,y=3pt]{\color{fg}\inserttocsectionnumber}
    \end{pgfpicture}\kern1em%
  \inserttocsection\par}
\newcommand{\fifte}[3]{\left\{
                              \begin{array}{l@{\quad\quad}l}
                                #2 & \mbox{si }#1 \\
                                #3 & \mbox{si no}
                              \end{array} 
                           \right.}\newcommand{\fassign}[2]{#1 := #2}
\newcommand{\true}{\textbf{true}}
\newcommand{\false}{\textbf{false}}
\newcommand{\fskipc}{\mbox{\textbf{skip}}}
\newcommand{\fiftec}[3]{\textbf{if}\ #1\ \textbf{then}\ #2\ \textbf{else}\ #3}
\newcommand{\fwhile}[2]{\textbf{while}\ #1\ \textbf{do}\ #2}
\newcommand{\fnewvar}[3]{\mbox{\textbf{newvar}\ #1:= #2\ \textbf{in}\ #3}}
\newcommand \supr{\vee}
\newcommand \infi{\wedge}
\newcommand{\se}[1]{\mbox{$[\![#1]\!]$}}
\newcommand{\sems}[1]{\sem{#1}\sigma}
\newcommand{\overs}[3]{[#1|#2:#3]}
\newcommand{\commif}[3]{\mathbf{if}\;#1\;\mathbf{then}\;#2\;\mathbf{else}\;#3}
\newcommand{\commseq}[2]{#1;#2}
\newcommand{\commassign}[2]{#1:=#2}
\newcommand{\commskip}{\mathbf{skip}}
\newcommand{\commwhile}[2]{\mathbf{while}\;#1\;\mathbf{do}\;#2}
\newcommand{\commnvar}[3]{\mathbf{newvar}\;#1:=#2\;\mathbf{in}\;#3}
\newcommand{\ptodo}[2]{\forall #1.\ #2}
\newcommand{\existe}[2]{\exists #1.\ #2}
\newcommand{\s}{\sigma }
\newcommand{\Z}{\textbf{Z}}
\newcommand{\la}{\left\langle }
\newcommand{\ra}{\right\rangle }
%\newcommand{\se}[1]{[\![#1]\!]}
\newcommand{\db}{\perp\!\!\!\perp}
\newcommand{\sem}[2]{[\![#1]\!]_{#2}}
\newcommand{\semnat}[1]{\sem{#1}{\nat}}
\newcommand{\semassert}[1]{\sem{#1}{\assert}}
\newcommand{\semintexp}[1]{\sem{#1}{\intexp}}
\newcommand{\semtheta}[1]{\sem{#1}{\theta}}
\newcommand{\semden}[1]{\sem{#1}{}}
\newcommand{\semop}[1]{\{\!\![#1]\!\!\}}
\newcommand{\syn}[1]{<\!\!#1\!\!>}
\newcommand{\conc}{+\!\!\!+}
\newcommand{\nat}{\left\langle nat\right\rangle}
\newcommand{\var}{\left\langle var\right\rangle}
\newcommand{\boolexp}{\left\langle boolexp\right\rangle}
\newcommand{\bin}{{\rm bin}}
\newcommand{\assert}{\left\langle assert\right\rangle}
\newcommand{\intexp}{\left\langle intexp\right\rangle }
\newcommand{\comm}{\left\langle comm\right\rangle}
\newcommand{\fun}{\left\langle fun\right\rangle}
\newcommand{\fvar}{\left\langle fvar\right\rangle}
\newcommand{\prog}{\left\langle prog\right\rangle}
\newcommand{\cnf}{\left\langle cnf\right\rangle}
\newcommand{\ife}{\mathbf{if}\ }
\newcommand{\lete}{\mathbf{let}\ }
\newcommand{\where}{\ \mathbf{where}\ }
\newcommand{\ine}{\ \mathbf{in}\ }
\newcommand{\thene}{\ \mathbf{then}\ }
\newcommand{\elsee}{\ \mathbf{else}\ }
\newcommand{\newvar}{\mathbf{newvar}\ }
\newcommand{\while}{\mathbf{while}\ }
\newcommand{\val}{\mathbf{val}\ }
\newcommand{\doc}{\ \mathbf{do}\ }
\newcommand{\env}{\left\langle env\right\rangle}
\newcommand{\penv}{\left\langle penv\right\rangle}
\newcommand{\ex}{\left\langle exp\right\rangle}
\newcommand{\natconst}{\left\langle natconst\right\rangle}
\newcommand{\boolconst}{\left\langle boolconst\right\rangle}
\newcommand{\pvar}{\left\langle pvar\right\rangle}
\newcommand{\proc}{\ \mathbf{proc}\ }
\newcommand{\va}[1]{\mathsf{#1}}



\title{Lenguajes y Compiladores}

%\author{Parte I:  }

\date{2016}

\AtBeginSubsection[]
{
  \begin{frame}<beamer>{Outline}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}


\beamerdefaultoverlayspecification{<+->}


\begin{document}




\begin{frame}
  \titlepage
\end{frame}


\begin{frame}{Estructura de la materia a grandes rasgos:}

\textbf{Primera Parte: } Lenguaje imperativooooooooooooooooooooo

\bigskip


\textbf{Segunda Parte: } Lenguaje aplicativo puro, y lenguaje aplicativo con referencias y asignación

\end{frame}

\begin{frame}{Ejes de contenidos de la segunda parte}
  \tableofcontents
\end{frame}

\section{Cálculo Lambda}


\begin{frame}{El Cálculo Lambda}
\note{
  La motivación original de Church era construir un sistema para lógica formal.
  El sistema formal propuesto por Church era inconsistente (un resultado probado
  por Kleene y Rosser. Sin embargo, el cálculo lambda sirvió para comprender
  mejor la noción de función.

  Los ejemplos motivadores 
  ¿qué función define $f(x) = x + y$? y ¿qué significa $a(b+c) = ab+ac$?
  muestran que en la práctica matemática usual se recurre a convenciones o
  enunciados extra-simbólicos para poder responder esas preguntas.
  
  Una de las ventajas del CL es que internaliza la noción de qué es lo
  que varía en cada uno de los casos. En particular, nos permite ver a
  las funciones como \emph{reglas} en vez de como \emph{conjuntos} (de pares
  ordenados).

  Nota bene: todas las funciones recursivas primitivas se pueden expresar
  en el cálculo lambda. Más aun, gracias a que tenemos operadores de punto
  fijo también podemos definir las funciones recursivas.

}

  \begin{itemize}
  \item<1-> Church (1930), continuado por Kleene, Rosser (1930s)
 
    \textbf{Motivación original}:  problemas de fundamentación de la matemática
  \item<2->
    \textbf{Como notación}: se usa para generar una expresión que denote una función, sin necesidad de dar nombre

    \textbf{Por ejemplo}: $f(x) = x+y$ se puede escribir 
    \[f = \lambda x.\ x+y, 
    \]
    con lo cual uno se puede referir a la función $f$ mediante la expresión $\lambda x.x+y$, sin necesidad de ponerle nombre. 

  \end{itemize}

\end{frame}


\begin{frame}{Sintaxis abstracta del CL}
  \note{
    En la propuesta original de Church había también constantes para introducir
    los conectivos y los cuantificadores.

    Más adelante nosotros también extenderemos el cálculo lambda con
    constantes y operadores para tener un lenguaje de programación, pero
    podemos ver que con este lenguaje podemos representar los naturales:

    $\lambda f.\lambda x. f\, x$


    $\lambda f.\lambda x. f\, (f\, x)$
    
    Y entonces el sucesor es simplemente ...
  }
\onslide<1->{
El CL puro sólo contiene variables, aplicaciones y la notación lambda (llamada abstracción).
\[
\begin{array}{llll}
\ex & ::= &  & \text{expresiones o términos}\\
 & & \  \var & \text{variables} \\
 & & \mid \ex \ex & \text{aplicación} \\ 
 & & \mid \lambda \var.\ \ex & \text{abstracción o expresión lambda} \\ 
 \end{array}
\]}
\onslide<2->{

\medskip

\textbf{Convención:} La aplicación asocia a izquierda. 
\smallskip
Por ejemplo, 
\smallskip
\qquad\qquad\qquad$\lambda x.(\lambda y.xyx)x$ 
\smallskip
es lo mismo que 
\smallskip
\qquad\qquad\qquad$\lambda x.(\lambda y.(xy)x)x$
}
\end{frame}


\begin{frame}{Variables libres }
\note{La abstracción es la construcción que construye una función: }

\onslide<1->{
  En la abstracción \[ \lambda x.x+2 \]
  se determina que estamos construyendo una función que varía de acuerdo
  a qué valor toma $x$. Es decir, la abstracción es un \emph{ligador}.

}

\onslide<2->{
\[
\begin{array}{llllll}
FV(v)& = & \{v\} \smallskip\\
FV(ee')& =  &FV(e) \cup FV(e')\smallskip\\
FV(\lambda v.e)& = & FV(e)\ -\  \{v\}\ \smallskip\\
\end{array}
\]
}

\end{frame}



\begin{frame}{Operador sustitución}
\note{

  La sustitución es una operación fundamental para poder comprender la
  forma en que se \emph{computa} dentro del cálculo lambda. Y definir
  correctamente la sustitución no es tarea trivial.

}

\uncover<1->{\textbf{Conjunto de sustituciones:} $\Delta = \var \rightarrow \ex$}
\smallskip
\uncover<2->{

\textbf{Operador  sustitución:} $\_/\_ \in \ex \times\Delta \rightarrow \ex$

}

\[
\begin{array}{rll}
\uncover<3->{
v/\delta &  = &  \delta v \smallskip\\
  (ee')/\delta & =& (e/\delta)(e'/\delta)\smallskip\\}
  \uncover<4->{
(\lambda v. e)/\delta&  =&  \lambda v_{new}.\  e/[\delta|v: v_{new}]\\
&&\text{ donde   
$v_{new} \not\in \bigcup_{w \in FV(e) -\{v\}} FV(\delta\ w)$}}
\end{array}
\]

\end{frame}


\begin{frame}{Conversión $\alpha$}

  \note{

    Si pensamos que con el cálculo lambda podemos pensar en las
    funciones como reglas, entonces nos podemos preguntar si las
    expresiones \[\lambda x.x \] y \[ \lambda y . y \] representan la
    misma regla (notemos que podríamos preguntarnos si otras
    expresiones también denotan la identidad, por ejemplo
    $\lambda x. (\lambda y . y) x$).

    La noción de renombre de variables ligadas nos permite identificar
    esas dos expresiones.

}
  
\uncover<1->{\textbf{Renombre: } Cambio en $\lambda v.e$ de la
  variable ligada $v$ (y todas sus ocurrencias) por una variable $v'$
  que no ocurra libre en $e$:
\[\lambda v'.\ e/v\mapsto v' \]
donde $v'\notin FV(e)$.}

\uncover<2->{
\bigskip

$\alpha$-\textbf{conversión}: Si $e_1$ se obtiene a partir de $e_0$ por 0
o más renombres de ocurrencias de subfrases. También se dice que $e_0$
$\alpha$-convierte a $e_1$.  }

\uncover<3->{

\textbf{Notación para expresiones $\alpha$- convertibles}: $e_0\equiv e_1$
}
\end{frame}


\begin{frame}{Ejecución: Contracción $\beta$}

\note{
  Ahora veremos la noción de ejecución. La idea es sencilla, $\lambda v.e$ denota
  la función que al aplicarla en $e'$ resulta en sustituir todas las ocurrencias 
  libres de $v$ en $e$ por $e'$.

  Las noción de \emph{contracción} la podemos dar axiomáticamente:

  \begin{minipage}[b]{.4\linewidth}
  \begin{prooftree}
    \AxiomC{ } \RightLabel{(redex)}
    \UnaryInfC{$(\lambda v.e)\ e' \to e/v \mapsto e'$}
  \end{prooftree}
  \begin{prooftree}
    \AxiomC{$e_0 \to e_1$}
    \AxiomC{$e_1 \equiv e'_1 $}\RightLabel{(renombre)}
    \BinaryInfC{$e \to e'_1$}
  \end{prooftree}
  \begin{prooftree}
    \AxiomC{$e_0 \to e_1$} \RightLabel{(clausura contextual)}
    \UnaryInfC{$C[e_o] \to C[e_1]$}
  \end{prooftree}
\end{minipage}

}

\uncover<1->{
\textbf{Redex:} Es una expresión de la forma $(\lambda v.e) e'$
}

\uncover<2->{
\bigskip

\textbf{Contracción $\beta$}: Reemplaza en $e_0$ una
ocurrencia de un redex ($\lambda v.e) e'$ por su contracción
$(e/v\mapsto e')$, y luego efectúa cero o más renombres de cualquier
subexpresión.  }

\uncover<3->{

\textbf{Notación}: Si $e_1$ es el resultado de una contracción $\beta$ de $e_0$, entonces escribimos
\[e_0\rightarrow e_1\]

}
\end{frame}



\begin{frame}{Ejecución: Formas normales}

\uncover<1->{
\textbf{Forma normal:} expresión sin redices. 

\bigskip

Las formas normales representan configuraciones terminales. 
}

\uncover<2->{
\bigskip

Por eso la semántica operacional del cálculo lambda consiste en efectuar contracciones $\beta$ hasta obtener formas normales.

\bigskip
}
\uncover<3>{
\textbf{Ejemplo:}

\medskip

$
\begin{array}{lllll}
 (\lambda x.\lambda y. (\lambda x.xy)(zx))(yz) &\rightarrow &
 (\lambda x.\lambda y. (zx)y)(yz)& \smallskip\\
\end{array}
$}

\uncover<4>{
\textbf{Ejemplo:}

\medskip

$
\begin{array}{lllll}
 (\lambda x.\lambda y. (\lambda x.xy)(zx))(yz) &\rightarrow &
 (\lambda x.\lambda y. (zx)y)(yz)& \smallskip\\
& \equiv &  (\lambda x.\lambda t. (zx)t)(yz)& \smallskip\\
\end{array}
$
}

\uncover<5>{

\textbf{Ejemplo:}

\medskip

$
\begin{array}{lllll}
 (\lambda x.\lambda y. (\lambda x.xy)(zx))(yz) &\rightarrow &
 (\lambda x.\lambda y. (zx)y)(yz)& \smallskip\\
& \equiv &  (\lambda x.\lambda t. (zx)t)(yz)& \smallskip\\
& \rightarrow &   \lambda t. z(yz)t& \\
\end{array}
$
}
\end{frame}

\begin{frame}{Ejecución: hay expresiones divergentes}
\uncover<1->{
Sea 
\[\Delta = \lambda x.xx\] 
entonces 
$\Delta\Delta$
no tiene forma normal:

\bigskip
}
\uncover<1>{
$
\begin{array}{lllll}
(\lambda x.xx)(\lambda x.xx) &\rightarrow &
 (\lambda x.xx)(\lambda x.xx)& \smallskip\\
\end{array}
$
}
\uncover<2>{
$
\begin{array}{lllll}
(\lambda x.xx)(\lambda x.xx) &\rightarrow &
 (\lambda x.xx)(\lambda x.xx)& \smallskip\\
& \rightarrow &   (\lambda x.xx)(\lambda x.xx)& \\
& & \qquad\vdots
\end{array}
$
}
\end{frame}

\begin{frame}{Ejecución: hay más de una forma de reducción}

\uncover<1->{En otros casos, la forma normal se puede encontrar si elegimos
correctamente qué redex reducir en cada caso:}

\uncover<2->{
\begin{tikzpicture}
  \node (e) at (2,2) {$(\lambda x.\lambda y.y) (\Delta \Delta)$} ;
  \node (e0) at (0,0) {$(\lambda x.\lambda y.y) (\Delta \Delta)$} ;
  \node (e1) at (4,0) {$\lambda y.y$} ;
  \node (e2) at (-2,-2) {$(\lambda x.\lambda y.y) (\Delta \Delta)$} ;
  \draw [->,-latex] (e) -- (e0);
  \draw [->,-latex] (e) -- (e1) ;
  \draw [->,-latex] (e0) -- (e2) ;
\end{tikzpicture}
}

\uncover<3->{Es decir la reducción no es determística.}
\end{frame}


\begin{frame}{Ejecución (formalmente)}

\uncover<1->{
$\rightarrow^*$ denota la clausura transitiva y refexiva de $\rightarrow$ 

\medskip 

(o sea, aplicar $\rightarrow$ cero o más veces)
}

\uncover<2->{
Por ejemplo, no existe $n$ forma normal tal que $\Delta\Delta\rightarrow^* n$
}

\uncover<3->{
\bigskip

\textbf{Formalmente:} 

\medskip

$e\rightarrow^* e'$ si y sólo si existen $e_0,...,e_{n}$ (con $n\geq 0$) tales que
\[e=e_0\rightarrow e_1\rightarrow ... \rightarrow e_{n}= e'\] 

\bigskip

Notar que si $n = 0$ entonces $e=e'$
}
\end{frame}


\begin{frame}{Si existe forma normal, es única}
\note{

  Mostrar cómo se aplica Church-Rosser al caso de no determinismo.
\begin{tikzpicture}
  \node (e) at (2,2) {$(\lambda x.\lambda y.y) (\Delta \Delta)$} ;
  \node (e0) at (0,0) {$(\lambda x.\lambda y.y) (\Delta \Delta)$} ;
  \node (e1) at (4,0) {$\lambda y.y$} ;
  \node (e2) at (-2,-2) {$(\lambda x.\lambda y.y) (\Delta \Delta)$} ;
  \draw [->,-latex] (e) -- (e0);
  \draw [->,-latex] (e) -- (e1) ;
  \draw [->,-latex] (e0) -- (e2) ;
\end{tikzpicture}

}

Es consecuencia inmediata de:

\bigskip


\textbf{Teorema de Church-Rosser} Si  $e\rightarrow^* e_0$  y $e\rightarrow^* e_1$,
entonces existe $e'$ tal que $e_0\rightarrow^* e'$ y $e_1\rightarrow^*  e'$.

\begin{tikzpicture}
  \node (e) at (2,2) {$e$} ;
  \node (e0) at (0,0) {$e_0$} ;
  \node (e1) at (4,0) {$e_1$} ;
  \node (e2) at (2,-2) {$e'$} ;
  \draw [->,-latex] (e) -- node [at end,above=1mm] {$^\ast$} (e0);
  \draw [->,-latex] (e) -- node [at end,above=1mm] {$^\ast$} (e1) ;
  \draw [style=dashed,->,-latex] (e0) -> node [at end,above=1mm] {$^\ast$} (e2) ;
  \draw [style=dashed,->,-latex] (e1) -> node [at end,above=1mm] {$^\ast$} (e2) ;
\end{tikzpicture}

\end{frame}


\begin{frame}{Regla $\eta$}
\note{

  Al principio dijimos que el cálculo lambda nos permitía tener una nueva
  formalización de funciones, no ya como conjuntos de pares ordenados sino
  como procesos. La igualdad de funciones, a su vez, dejaba de ser extensional
  (dos funciones son iguales si tienen el mismo conjunto de pares ordenados).
  
  Si pensamos en cómo habíamos definido la (des)igualdad de funciones
  en la primera parte de la materia, sin embargo, no nos encontramos
  con que hablábamos de conjuntos de pares, sino que testeábamos la igualdad
  en cada argumento: $f = g$ sii $f\, a = g\, a$ para todo $a$.

  La regla $\eta$ nos permite recobrar esa noción de extensionalidad, en el
  sentido que identifica la función $\lambda x.e\, x$ con la expresión $e$.
  Si bien intensionalmente ambas expresiones son distintas, podemos ver que
  al aplicarlas a cualquier argumento obtenemos lo mismo. 

}

\uncover<1->{Un $\eta$-redex es una expresión de la forma $\lambda v.e v$, donde $v\notin FV\ e$
\bigskip
}

\uncover<2->{
  \begin{prooftree}
    \AxiomC{ } \RightLabel{si $v\notin FV\ e$\qquad ($\eta$)}
    \UnaryInfC{$\lambda v.e\, v \to e$}
  \end{prooftree}
}
\end{frame}

\begin{frame}{Evaluación}

$\rightarrow^*$ no representa adecuadamente la ejecución de los lenguajes aplicativos. \pause
\medskip
En los lenguajes aplicativos la evaluación \pause
\medskip
\begin{enumerate}
\item sólo para expresiones cerradas, 
\item es determinística,
\item no busca formas normales sino formas canónicas.
\end{enumerate}\pause

\bigskip

Vamos a estudiar:

\medskip

\textbf{Evaluación (en orden) normal}: lenguajes funcionales lazy (Haskell)

\medskip

\textbf{Evaluación eager o estricta}: lenguajes estrictos (ML).

\end{frame}


\begin{frame}{Formas canónicas}

La evaluación busca una forma canónica, las mismas juegan el rol de ser "valores" de expresiones. \pause

\medskip

La noción de forma canónica depende de la definición de evaluación. Se define
una noción de forma canónica para la evaluación normal, y otra para la
evaluación eager. \pause

\medskip

En el caso del cálculo lambda coinciden: \textbf{son las abstracciones}
\end{frame}



\begin{frame}{Formas canónicas vs. formas normales}

\textbf{Propiedad}: Una aplicación cerrada no puede ser forma normal. \pause

\bigskip

\textbf{Corolario}:  una expresión cerrada que es forma normal es
también forma canónica. 

\bigskip

El recíproco no vale. 

\bigskip

\end{frame}


\begin{frame}{Formas canónicas}

¿Por qué conformarse con una forma canónica en vez de continuar ejecutando hasta
obtener una forma normal? \pause

\bigskip

Sólo tiene sentido evaluar expresiones cerradas. \pause

\bigskip

Una vez que se alcanzó una abstracción $\lambda v.e$, continuar evaluando implicaría evaluar $e$ que puede no ser una expresión cerrada, puede contener a la variable $v$.

\end{frame}


\begin{frame}{Semántica natural o big-step}

  En este tipo de semántica, uno no describe un paso de ejecución,
  sino directamente una relación entre los términos y sus valores (que
  también son términos, son formas canónicas). \pause

\bigskip

Llamaremos $\Rightarrow$ a esta relación.

\end{frame}



\begin{frame}{Evaluación Normal}

\textbf{Reglas para} $\Rightarrow_N$

\bigskip

Regla para las formas canónicas

\bigskip

$\begin{array}{c}
\overline{\lambda v.e\ \Rightarrow_N\ \lambda v.e}
\end{array}
$
\pause
\bigskip

\medskip


Regla para la aplicación

\bigskip

$\begin{array}{c}
\underline{e\ \Rightarrow_N\ \lambda v.e_0\qquad (e_0/v\mapsto e')\ \Rightarrow_N\ z}\\
ee'\ \Rightarrow_N\ z
\end{array}
$

\end{frame}


\begin{frame}{Evaluación Eager}

\textbf{Reglas para} $\Rightarrow_E$

\bigskip

Regla para las formas canónicas

\bigskip

$\begin{array}{c}
\overline{\lambda v.e\ \Rightarrow_E\ \lambda v.e}
\end{array}
$
\pause
\bigskip

\medskip


Regla para la aplicación

\bigskip

$\begin{array}{c}
\underline{e\ \Rightarrow_E\ \lambda v.e_0\qquad e'\ \Rightarrow_E\ z'\qquad(e_0/v\mapsto z')\ \Rightarrow_E\ z}\\
ee'\ \Rightarrow_E\ z
\end{array}
$
\end{frame}
\end{document}


\begin{frame}{Semántica Denotacional del Cálculo Lambda}

Surge con Church, trantado de construir un sistema formal completo como fundamentación última de la matemática. En 1934 Kleene and Rosser publicaron una implementación de la paradoja de Richard,y comienza a ser usado para estudiar la computabilidad, culminando en la respuesta negativa al problema de la parada (Turing 1936). 


\end{frame}



\begin{frame}{Semántica Denotacional del Cálculo Lambda}

\bigskip

Requisito inicial para su semántica: 

\medskip

un conjunto $C$ tal que $C$ es isomorfo a $C\rightarrow C$

\end{frame}



\begin{frame}{Semántica Denotacional del Cálculo Lambda}

\bigskip

Requisito inicial para su semántica: 

\medskip

un conjunto $C$ tal que $C$ es isomorfo a $C\rightarrow C$

\bigskip

\textbf{Paradoja}: Sea $f$ cualquier función, y definamos $p x = f (x x)$

\medskip

Entonces $pp$ es punto fijo de $f$. 
\end{frame}



\begin{frame}{Semántica Denotacional del Cálculo Lambda}

\bigskip

Requisito inicial para su semántica: 

\medskip

un conjunto $C$ tal que $C$ es isomorfo a $C\rightarrow C$

\bigskip

\textbf{Paradoja}: Sea $f$ cualquier función, y definamos $p x = f (x x)$

\medskip

Entonces $pp$ es punto fijo de $f$. 

\bigskip

\textbf{Scott-Strachey 1972-1981 Oxford} Definen la semántica utilizando dominios:
\[D_\infty\ \  \simeq\ \ D_\infty \rightarrow D_\infty\]
\end{frame}



\begin{frame}{Semántica Denotacional del Cálculo Lambda}

Asumimos la existencia de un dominio $D_{\infty}$, junto con isomorfismos:

\bigskip

$\phi\in D_{\infty}\rightarrow(D_{\infty}\rightarrow D_{\infty})$

\medskip

$\psi\in (D_{\infty}\rightarrow D_{\infty})\rightarrow D_{\infty}$


\bigskip

$\phi \circ \psi = Id_{D_{\infty}\rightarrow D_{\infty}}$

\medskip

$\psi\circ\phi = Id_{D_{\infty}}$

\end{frame}



\begin{frame}{Semántica Denotacional del Cálculo Lambda}

\textbf{Ambientes (Entornos):} $Env = (\langle var\rangle\rightarrow D_\infty)$

\bigskip

\textbf{Notación: } $\eta\in Env$ será un ambiente. 

\end{frame}


\begin{frame}{Semántica Denotacional del Cálculo Lambda}

\textbf{Ambientes (Entornos):} $Env = (\langle var\rangle\rightarrow D_\infty)$

\bigskip

\textbf{Notación: } $\eta\in Env$ será un ambiente. 

\bigskip

\textbf{Función semántica:} $\se{\_}\in\ \ \langle exp\rangle \rightarrow Env\rightarrow D_{\infty}$


\end{frame}



\begin{frame}{Semántica Denotacional del Cálculo Lambda}

\textbf{Ambientes (Entornos):} $Env = (\langle var\rangle\rightarrow D_\infty)$

\bigskip

\textbf{Notación: } $\eta\in Env$ será un ambiente. 

\bigskip

\textbf{Función semántica:} $\se{\_}\in\ \ \langle exp\rangle \rightarrow Env\rightarrow D_{\infty}$

\bigskip

\textbf{Ecuaciones semánticas:}

\bigskip

$\se{v}\eta = \eta v$

\end{frame}


\begin{frame}{Semántica Denotacional del Cálculo Lambda}

\textbf{Ambientes (Entornos):} $Env = (\langle var\rangle\rightarrow D_\infty)$

\bigskip

\textbf{Notación: } $\eta\in Env$ será un ambiente. 

\bigskip

\textbf{Función semántica:} $\se{\_}\in\ \ \langle exp\rangle \rightarrow Env\rightarrow D_{\infty}$

\bigskip

\textbf{Ecuaciones semánticas:}

\bigskip

$\se{v}\eta = \eta v$


\bigskip

$\se{e_0 e_1}\eta = \phi(\se{e_0}\eta)\ \se{e_1}\eta$


\end{frame}


\begin{frame}{Semántica Denotacional del Cálculo Lambda}

\textbf{Ambientes (Entornos):} $Env = (\langle var\rangle\rightarrow D_\infty)$

\bigskip

\textbf{Notación: } $\eta\in Env$ será un ambiente. 

\bigskip

\textbf{Función semántica:} $\se{\_}\in\ \ \langle exp\rangle \rightarrow Env\rightarrow D_{\infty}$

\bigskip

\textbf{Ecuaciones semánticas:}

\bigskip

$\se{v}\eta = \eta v$


\bigskip

$\se{e_0 e_1}\eta = \phi(\se{e_0}\eta)\ \se{e_1}\eta$

\bigskip

$\se{\lambda v.e}\eta = \psi(\lambda d\in D_\infty. \se{e}[\eta|v:d])$

\end{frame}



\begin{frame}{Propiedades de la semántica del CL}

\textbf{Teorema de Coincidencia:}

Si $\eta w = \eta' w$ para todo $w\in FV\ e$, entonces $\se{e}\eta = \se{e}\eta'.$

\end{frame}



\begin{frame}{Propiedades de la semántica del CL}

\textbf{Teorema de Coincidencia:}

Si $\eta w = \eta' w$ para todo $w\in FV\ e$, entonces $\se{e}\eta = \se{e}\eta'.$

\bigskip

\textbf{Teorema de Renombre:} Si $v_{new}\notin FV\ e-\{v\}$, 

entonces $\se{\lambda v_{new}.(e/v\mapsto v_{new})} = \se{\lambda v.e}.$


\end{frame}





\begin{frame}{Propiedades de la semántica del CL}

\textbf{Teorema de Coincidencia:}

Si $\eta w = \eta' w$ para todo $w\in FV\ e$, entonces $\se{e}\eta = \se{e}\eta'.$

\bigskip

\textbf{Teorema de Renombre:} Si $v_{new}\notin FV\ e-\{v\}$, 

entonces $\se{\lambda v_{new}.(e/v\mapsto v_{new})} = \se{\lambda v.e}.$

\bigskip

\textbf{Sustituciones:} $\Delta \ = \ \ \langle var\rangle \rightarrow  \langle exp\rangle$


\end{frame}


\begin{frame}{Propiedades de la semántica del CL}

\textbf{Teorema de Coincidencia:}

Si $\eta w = \eta' w$ para todo $w\in FV\ e$, entonces $\se{e}\eta = \se{e}\eta'.$

\bigskip

\textbf{Teorema de Renombre:} Si $v_{new}\notin FV\ e-\{v\}$, 

entonces $\se{\lambda v_{new}.(e/v\mapsto v_{new})} = \se{\lambda v.e}.$

\bigskip

\textbf{Sustituciones:} $\Delta \ = \ \ \langle var\rangle \rightarrow  \langle exp\rangle$

\bigskip

\textbf{Teorema de Sustitución}: Si $\se{\delta w}\eta = \eta' w$ para todo $w \in FV\ e$, entonces $\se{e/\delta}\eta = \se{e}\eta'$.

\end{frame}


\begin{frame}{Reglas $\beta$ y $\eta$}

Son válidas en el Cálculo Lambda:

\bigskip

$\se{(\lambda v.e)e'}\eta = \se{e/v\mapsto e'}\eta$

\bigskip

$\se{\lambda v.ev}\eta = \se{e}\eta$, si $v\notin FV e$

\end{frame}



\begin{frame}{Problema}

\textbf{La semántica denotacional dada no representa la evaluación de los lenguajes funcionales}


\end{frame}


\begin{frame}{Problema}

\textbf{La semántica denotacional dada no representa la evaluación de los lenguajes funcionales}

\bigskip


Observar que $\lambda x. e$ se evalúa como función en cualquier modalidad de evaluación (tanto eager como normal).


\end{frame}



\begin{frame}{Problema}

\textbf{La semántica denotacional dada no representa la evaluación de los lenguajes funcionales}

\bigskip


Observar que $\lambda x. e$ se evalúa como función en cualquier modalidad de evaluación (tanto eager como normal).

\bigskip

Pero $\se{\lambda v. \Delta\Delta} = \perp$

\end{frame}



\begin{frame}{Semántica Denotacional Normal}

Hay que distinguir las semántica de $\lambda v. \Delta\Delta$ y $\Delta\Delta$

\end{frame}

\begin{frame}{Semántica Denotacional Normal}

Hay que distinguir las semántica de $\lambda v. \Delta\Delta$ y $\Delta\Delta$

\bigskip

Los "valores" (conjunto $V$), representan a las formas canónicas:
\[ V\ \ \approx\ \  D\rightarrow D\]

\end{frame}


\begin{frame}{Semántica Denotacional Normal}

Hay que distinguir las semántica de $\lambda v. \Delta\Delta$ y $\Delta\Delta$

\bigskip

Los "valores" (conjunto $V$), representan a las formas canónicas:
\[ V\ \ \approx\ \  D\rightarrow D\]

Definimos el conjunto de resultados posibles como :
\[D \ =\ V_\perp\]

\end{frame}


\begin{frame}


Asumimos la existencia de un dominio $D$, junto con isomorfismos:

\bigskip

$\phi\in V\rightarrow(D\rightarrow D)$

\medskip

$\psi\in (D\rightarrow D)\rightarrow V$


\bigskip

$\phi \circ \psi = Id_{D\rightarrow D}$

\medskip

$\psi\circ\phi = Id_{V}$

\bigskip

\textbf{Notación: }\ \ $\iota_\perp\in V\rightarrow D$

\end{frame}








\begin{frame}{Semántica Denotacional del Cálculo Lambda Normal}

Dominio Semántico: $D \ = V_\perp \qquad  V\ \approx\ (D\rightarrow D)$

\end{frame}




\begin{frame}{Semántica Denotacional del Cálculo Lambda Normal}

Dominio Semántico: $D \ = V_\perp \qquad  V\ \approx\ (D\rightarrow D)$

\bigskip

\textbf{Ambientes:} $Env = (\langle var\rangle\rightarrow D)$

\end{frame}



\begin{frame}{Semántica Denotacional del Cálculo Lambda Normal}

Dominio Semántico: $D \ = V_\perp \qquad  V\ \approx\ (D\rightarrow D)$

\bigskip

\textbf{Ambientes:} $Env = (\langle var\rangle\rightarrow D)$

\bigskip

\textbf{Función semántica:} $\se{\_}\in\ \ \langle exp\rangle \rightarrow Env\rightarrow D$

\end{frame}



\begin{frame}{Semántica Denotacional del Cálculo Lambda Normal}

Dominio Semántico: $D \ = V_\perp \qquad  V\ \approx\ (D\rightarrow D)$

\bigskip

\textbf{Ambientes:} $Env = (\langle var\rangle\rightarrow D)$

\bigskip

\textbf{Función semántica:} $\se{\_}\in\ \ \langle exp\rangle \rightarrow Env\rightarrow D$

\bigskip

\textbf{Ecuaciones semánticas:}

\bigskip

$\se{v}\eta = \eta v$

\end{frame}



\begin{frame}{Semántica Denotacional del Cálculo Lambda Normal}

Dominio Semántico: $D \ = V_\perp \qquad  V\ \approx\ (D\rightarrow D)$

\bigskip

\textbf{Ambientes:} $Env = (\langle var\rangle\rightarrow D)$

\bigskip

\textbf{Función semántica:} $\se{\_}\in\ \ \langle exp\rangle \rightarrow Env\rightarrow D$

\bigskip

\textbf{Ecuaciones semánticas:}

\bigskip

$\se{v}\eta = \eta v$


\bigskip

$\se{e_0 e_1}\eta = \phi_{\perp\!\!\!\perp}(\se{e_0}\eta) (\se{e_1}\eta)$


\end{frame}



\begin{frame}{Semántica Denotacional del Cálculo Lambda Normal}

Dominio Semántico: $D \ = V_\perp \qquad  V\ \approx\ (D\rightarrow D)$

\bigskip

\textbf{Ambientes:} $Env = (\langle var\rangle\rightarrow D)$

\bigskip

\textbf{Función semántica:} $\se{\_}\in\ \ \langle exp\rangle \rightarrow Env\rightarrow D$

\bigskip

\textbf{Ecuaciones semánticas:}

\bigskip

$\se{v}\eta = \eta v$


\bigskip

$\se{e_0 e_1}\eta = \phi_{\perp\!\!\!\perp}(\se{e_0}\eta) (\se{e_1}\eta)$

\bigskip

$\se{\lambda v.e}\eta =\  \iota_\perp\circ\psi\ (\lambda d\in D. \se{e}[\eta|v:d])$

\end{frame}


\begin{frame}

¿Cuáles son todas las posibilidades para que $e_0e_1$ tenga semántica $\perp$


\bigskip


Notar que $\phi_{\perp\!\!\!\perp} \perp\  \ \ =\  \ \perp_{D\rightarrow D}$.


\end{frame}



\begin{frame}

¿Cuáles son todas las posibilidades para que $e_0e_1$ tenga semántica $\perp$?


\bigskip


Notar que $\phi_{\perp\!\!\!\perp} \perp\  \ \ =\  \ \perp_{D\rightarrow D}$.


\bigskip

Si bien la semántica denotacional no expresa un orden de evaluación ya que no es operacional, establece indirectamente el orden natural en que debe evaluarse.

\end{frame}



\begin{frame}

¿Cuáles son todas las posibilidades para que $e_0e_1$ tenga semántica $\perp$?


\bigskip


Notar que $\phi_{\perp\!\!\!\perp} \perp\  \ \ =\  \ \perp_{D\rightarrow D}$.

\bigskip

Si bien la semántica denotacional no expresa un orden de evaluación ya que no es operacional, establece indirectamente el orden natural en que debe evaluarse.

\bigskip

Por más que $\se{e_1}\eta = \perp$, no necesariamente $\se{e_0e_1}\eta = \perp$ . Eso indica que $e_1$ no necesariamente debe evaluarse para evaluarse $e_0 e_1$.

\end{frame}



\begin{frame}{Propiedades de la Semántica Denotacional Normal }

Los teoremas que vimos antes siguen valiendo. 

\end{frame}



\begin{frame}{Propiedades de la Semántica Denotacional Normal }

Los teoremas que vimos antes siguen valiendo. 

\bigskip

También vale la regla $\beta$, que utiliza la igualdad: 
\[\phi_{\perp\!\!\!\perp}\circ (\iota_\perp \circ \psi) = Id_{D\rightarrow D}\]

\end{frame}


\begin{frame}{Propiedades de la Semántica Denotacional Normal }

Los teoremas que vimos antes siguen valiendo. 

\bigskip

También vale la regla $\beta$, que utiliza la igualdad: 
\[\phi_{\perp\!\!\!\perp}\circ (\iota_\perp \circ \psi) = Id_{D\rightarrow D}\]

No vale la regla $\eta$. 

\end{frame}




%EAGER






\begin{frame}{Modalidad EAGER}

\textbf{La semántica denotacional del cálculo Lambda, ni la normal representan la evaluación de los lenguajes funcionales eager}

\bigskip


Por ejemplo: $(\lambda x. \lambda y. y) (\Delta\Delta)$


\bigskip

La aplicación se efectúa cuando el operando se haya evaluado. Desde el punto de vista semántico, las funciones toman valores solamente. 

\end{frame}




\begin{frame}{Semántica Denotacional Eager}

Los "valores" (conjunto $V$), representan a las formas canónicas, pero ahora son funciones que sólo toman valores:
\[ V\ \ \approx\ \  V\rightarrow D\]

\end{frame}


\begin{frame}{Semántica Denotacional Eager}

Los "valores" (conjunto $V$), representan a las formas canónicas, pero ahora son funciones que sólo toman valores:
\[ V\ \ \approx\ \  V\rightarrow D\]

Definimos el conjunto de resultados posibles como :
\[D \ =\ V_\perp\]

\end{frame}


\begin{frame}


Asumimos la existencia de un dominio $D$, junto con isomorfismos:

\bigskip

$\phi\in V\rightarrow(V\rightarrow D)$

\medskip

$\psi\in (V\rightarrow D)\rightarrow V$


\bigskip

$\phi \circ \psi = Id_{V\rightarrow D}$

\medskip

$\psi\circ\phi = Id_{V}$

\bigskip

\textbf{Notación: }\ \ $\iota_\perp\in V\rightarrow D$

\end{frame}







\begin{frame}{Semántica Denotacional del Cálculo Lambda Eager}

Dominio Semántico: $D \ = V_\perp \qquad  V\ \approx\ (V\rightarrow D)$

\bigskip

\textbf{Ambientes:} $Env = (\langle var\rangle\rightarrow V)$


\end{frame}


\begin{frame}{Semántica Denotacional del Cálculo Lambda Eager}

Dominio Semántico: $D \ = V_\perp \qquad  V\ \approx\ (V\rightarrow D)$

\bigskip

\textbf{Ambientes:} $Env = (\langle var\rangle\rightarrow V)$

\bigskip

\textbf{Función semántica:} $\se{\_}\in\ \ \langle exp\rangle \rightarrow Env\rightarrow D$

\end{frame}



\begin{frame}{Semántica Denotacional del Cálculo Lambda Eager}

Dominio Semántico: $D \ = V_\perp \qquad  V\ \approx\ (V\rightarrow D)$

\bigskip

\textbf{Ambientes:} $Env = (\langle var\rangle\rightarrow V)$

\bigskip

\textbf{Función semántica:} $\se{\_}\in\ \ \langle exp\rangle \rightarrow Env\rightarrow D$

\bigskip

\textbf{Ecuaciones semánticas:}

\bigskip

$\se{v}\eta = \iota_\perp(\eta v)$

\end{frame}




\begin{frame}{Semántica Denotacional del Cálculo Lambda Eager}

Dominio Semántico: $D \ = V_\perp \qquad  V\ \approx\ (V\rightarrow D)$

\bigskip

\textbf{Ambientes:} $Env = (\langle var\rangle\rightarrow V)$

\bigskip

\textbf{Función semántica:} $\se{\_}\in\ \ \langle exp\rangle \rightarrow Env\rightarrow D$

\bigskip

\textbf{Ecuaciones semánticas:}

\bigskip

$\se{v}\eta = \iota_\perp(\eta v)$


\bigskip

$\se{e_0 e_1}\eta = \phi_{\perp\!\!\!\perp}(\se{e_0}\eta)_{\perp\!\!\!\perp} \se{e_1}\eta$

\end{frame}

\begin{frame}{Semántica Denotacional del Cálculo Lambda Eager}

Dominio Semántico: $D \ = V_\perp \qquad  V\ \approx\ (V\rightarrow D)$

\bigskip

\textbf{Ambientes:} $Env = (\langle var\rangle\rightarrow V)$

\bigskip

\textbf{Función semántica:} $\se{\_}\in\ \ \langle exp\rangle \rightarrow Env\rightarrow D$

\bigskip

\textbf{Ecuaciones semánticas:}

\bigskip

$\se{v}\eta = \iota_\perp(\eta v)$


\bigskip

$\se{e_0 e_1}\eta = \phi_{\perp\!\!\!\perp}(\se{e_0}\eta)_{\perp\!\!\!\perp} \se{e_1}\eta$

\bigskip

$\se{\lambda v.e}\eta =\  \iota_\perp\circ\psi\ (\lambda z\in V. \se{e}[\eta|v:z])$

\end{frame}





\begin{frame}{Propiedades de la Semántica Denotacional Eager }

Los teoremas que vimos antes siguen valiendo. 

\end{frame}



\begin{frame}{Propiedades de la Semántica Denotacional Eager }

Los teoremas que vimos antes siguen valiendo. 

\bigskip

Ya no vale  la regla $\beta$. 

\bigskip

\qquad$\se{(\lambda v.e)e'}\eta = (\lambda z\in V. \se{e}[\eta|v:z])_{\perp\!\!\!\perp}\se{e'}\eta$

\medskip

Considerar: $\se{e'}\eta=\perp$, $v$, no ocurre en $e$,  y $\se{e}\eta\neq\perp$

\medskip

Entonces $\se{(\lambda v.e)e'}\eta = \perp$ y $\se{e/v\mapsto e'}\eta \neq\perp$ 

\bigskip

No vale la regla $\eta$. 

\end{frame}






\section{Lenguajes Aplicativos puros}


\begin{frame}

\end{frame}


\section{Un Lenguaje Aplicativo con referencias y asignación}


\begin{frame}

\end{frame}

\end{document}



